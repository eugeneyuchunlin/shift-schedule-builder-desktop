\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or eps§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb, paralist}
\usepackage{verbatim}
\usepackage[utf8]{inputenc}
\usepackage{pmboxdraw}
\usepackage{listings}
\graphicspath{ {./images/} }

%SetFonts

\geometry{top=1.5cm}
\title{Shift Schedule Builder Desktop - Client Server}
\author{Yu-Chun Lin and Kuei-Ching Yang}
%\date{}							% Activate to display a given date or no date

\begin{document}
\maketitle
\section{Description}
Shift Schedule Builder Desktop is an application designed to simplify the task of shift arrangement for employees. Its primary aim is to provide a user-friendly interface that allows users to input their shift requirements and configurations easily and generate a shift that satisfies these shift requirements as much as possible.

The user can set up some basic shift parameters such as the number of days and the number of employees. The application will generate an empty shift that satisfies the basic requirement. In addition to basic shift parameters, users are able to add some shift requirements. The application provides several common shift requirements. For example, users are able to set up the expected number of working days in the given range of the shift. The application will automatically generate a schedule for them based on the given data and constraints. Since the scheduling problem is a multi-objective optimization problem, the users have to specify the weight of each constraint. If the user values a shift requirement a lot, the user has to specify a bigger weight on that shift requirement.

The project is developed using Python, HTML, Javascript, and CSS.
\subsection{UI Sketch}
We developed the UI by using HTML, Javascript, and CSS for both desktop-based client and a web-based client. We employed \textbf{QWebEngineView} and \textbf{QWebEnginePage} to embed the HTML, Javascript, and CSS code in the desktop-based client.
We opted to integrate the website into the desktop-based client primarily due to the website's more user-friendly and aesthetically pleasing design. Furthermore, there is no gap or learning curve for users transitioning from the web-based application to the desktop-based application. Both applications maintain a consistent user experience.

\subsubsection{Login}
In the beginning, the user has to log in. The login page will collect the username and password of the user to check and set up different users. The login page serves as a view and controller in the application. After collecting the user's information, it will send the information to the backend's database adapter to check if the user exists or not.

After receiving the user's information, the application will store the information by using Cookies. 

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{login_window}
\caption{User Interface - Login Dialog}
\label{uilogin}
\end{figure}

\subsubsection{Main Page}
The main page enables users to create multiple shifts by adding tabs and setting up the parameters. The main page is composed of several components. The UI components are shown in the figure below. The details of the design pattern will be elaborated in the architecture design section.
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{main_window}
\caption{User Interface - Main Window}
\label{uimainwindow}
\end{figure}

\iffalse
\begin{verbatim}
.
├── README.md
├── app.py
├── config.yml
├── requirements.txt
├── src
│   ├── algorithms
│   │    ...
│   ├── model
│   │   ...
│   ├── ui
│   │   ├── __init__.py
│   │   ├── form.ui
│   │   ├── login.py
│   │   ├── parameters_form.py
│   │   ├── shift_table.py
│   │   ├── table_widget.py
│   │   ├── tabs.py
│   │   ├── ui.py
│   │   ├── ui_form.py
│   │   └── working_area.py
│   └── utility
│       ├── ...
│       └── ...
└── unittests.py
\end{verbatim}
\fi

\subsection{Main use cases}

\subsubsection{Login}
\begin{description}
\item[Use case:] Login
\item[Actor:] System user
\item[Goal:] To login to the system
\item[Overview:] When the users open the application, they have to sign in to the system. 
If they type their username and password correctly, they are able to sign in. 
However, if they type either username or password wrong, the system will pop up a window showing a message that tells the users they failed to sign in.
\item[Actor action:]
\
\begin{enumerate}
\item user: A user types username and password
\item user: The user clicks the login button
\item system: If both username and password are correct, then the system will allow the user to log in; otherwise, the system will pop up a message that tells the user that the given information is not correct.
\item user: If the user fails to login, the user may click the close button to close the application; otherwise, the system will close the login dialog window and show the application's user interface.
\end{enumerate}

\item[Alternative courses:]
\
\begin{description}
\item[Steps 1 and 2:] The user may click the close button to close the application.
\end{description}

\end{description}

\subsubsection{Create a new shift}
\begin{description}
\item[Use Case: ] Create a new shift
\item[Actor: ] System user
\item[Goal: ] To create a new empty shift
\item[Overview: ] Before the application generates a shift for the user, the user has to create a new empty shift.
\item[Actor action: ]
\
\begin{enumerate}
\item user: A user clicks the '+' button at the tab line.
\item system: The system create a new empty shift.
\item user: The user may set up shift parameters.
\end{enumerate}
\
\item[Alternative courses:]
\
\begin{description}
\item[Steps 1 and 2:] The user may click the close button to close the application.
\end{description}
\end{description}

\subsubsection{Set up shift parameters}
\begin{description}
\item[Use case:] Set up shift parameters
\item[Actor:] System user
\item[Goal:] To set up shift parameters
\item[Overview:] Before the application generates a shift for the user, the user has to specify the shift parameters.
The parameters include days, number of workers, computation time, and running mode.
\item[Actor action:]
\
\begin{enumerate}
\item user: A user types the number of days in the parameters form.
\item system: The system regenerates a shift based on a new parameter configuration.
\item user: The user types the number of workers in the parameter form.
\item system: The system regenerates a shift based on a new parameter configuration.
\item user: The user types the computation time in the parameter form.
\end{enumerate}

\item[Alternative courses:]
\
\begin{description}
\item[Steps 1 and 2:] The user may click the close button to close the application.
\end{description}

\end{description}

\subsubsection{Sets up shift requirements}
\begin{description}
\item[user case:] Set up shift requirements
\item[Actor:] System user
\item[Goal:]To sets up shift requirements
\item[Overview:] Before the application generates a shift for the user, the user is able to give some shift requirements.
The available shift requirements are the expected number of working days, the expected number of workers per shift, the successive shift pair, the consecutive 2 days off,  no more than consecutive days off, the maximum number of consecutive shifts, and the minimum number of N days off within 7 days.
\item[Actor action:]
\
\begin{enumerate}
\item user: The user clicks one of the shift requirements.
\item system: The system pops up a dialog that shows the description of the parameter and ask the user to provide the parameter of the shift requirement.
\item user: The user provides the preferred parameters.
\item user: The user clicks the Add button to add the parameters.
\end{enumerate}

\item[Alternative courses]
\
\begin{description}
\item[Steps 3 and 4:] The user may click the close button to close the dialog.
\end{description}

\end{description}


\subsubsection{Generate a shift}
\begin{description}
\item[user case:] Generate a shift requirements
\item[Actor:] System user
\item[Goal:] To generate a shift
\item[Overview:]After the user finishes setting up the parameters and requirements, the user is ready to generate a shift. The user can click the "Generate" button to start generating the shift.
\item[Actor action:]
\
\begin{enumerate}
\item user: The user clicks the Generate button to start generating a shift.
\item system: The Generate button becomes disabled and starts generating a shift for the user.
\item system: The progress bar will keep posted on the status of the task.
\item system: When finishing generating a shift, the system shows the shift on the user interface.
\item system: The Generate button will be unlocked so that users can re-run the task.
\end{enumerate}
\item[Alternative courses]
\
\begin{description}
\item[Steps 3 and 4:] The user may click the close button to close the dialog.
\end{description}
\end{description}

\subsubsection{Save a shift}
\begin{description}
\item[user case:] Save a shift
\item[Actor:] System user
\item[Goal:] To save a shift
\item[Overview:]After acquiring a shift, the user is able to save his/her shift to the device.
\item[Actor action:]
\
\begin{enumerate}
\item user: The user clicks download button on the website.
\item system: The system directly download the file to user's device.
\item user: The user open the file at the default download directory.
\end{enumerate}
\end{description}

\subsubsection{Logout}
\begin{description}
\item[user case:] Logout
\item[Actor:] System user
\item[Goal:] To log out
\item[Overview:] Users can log out of the system or switch to a different user.
\item[Actor action:]
\
\begin{enumerate}
\item user: The user clicks logout button on the website at navigation bar area.
\item system: The system delete the Cookies and return to the login page.
\end{enumerate}
\end{description}

\section{Database design}
The data models of the application are intricate. The database not only has to store the user’s information but also the shift data. Since users are allowed to set up multiple shift requirements, the number of shift constraints will vary. Besides, the data size of the shift will vary based on the number of days and the number of workers. It is intuitive to use the NoSQL database to store and load the data; thus, we choose to use Redis and MongoDB to store the data. Redis is responsible for storing the user's data. The key is the combination of user's username and password. The data of the user stored in Redis is in JSON format. The document and the data model of the application are compatible. In MongoDB we create a collection to store shift data. The entity relationship diagram is shown below.


\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{ erd }
\caption{Entity Relationship Diagram}
\label{erd}
\end{figure}


\subsection{Users}
In Redis, the database stores the basic information of a user such as username, password, email, and shifts. Here is an example of a entry. 

\begin{verbatim}
{
    username: 'admin',
    password: 'password',
    email: 'email@gmail.com',
    shifts: [
      '66d74521-6947-4cd3-b2e9-d201140893bb',
      '0926ea12-8907-43e7-a2cb-340043eb7c12',
      '9223cea4-69f8-4dab-8832-4b48c952d91d',
      '0750a390-7f19-4341-9aa2-f41ccfc2c0f9'
    ]
}

\end{verbatim}
The description of those fields is as follows.
\begin{compactenum}[1.]
\item username: The username of the user.
\item password: The password of the user.
\item email: The email of the user.
\item shifts: A nested document that stores the shift is owned by the user. In this example, the user owns 4 shifts. The shifts ID will be used to load the shifts in the Shifts collection.
\end{compactenum}

\subsection{Shifts}
The collection stores shifts' information. The shifts' information includes shift\_id, parameters, and the content of the shift. Here is a snippet of a document in the collection.
\begin{verbatim}
[
  {
    _id: ObjectId("6519d6a87b2c1ef5a957ae5c"),
    shift_id: '594f91af-cade-47f3-aeff-a0d461285e1a',
    computation_time: 30,
    constraints: [
      {
        name: 'expected_number_of_working_days',
        parameters: { weight: '10', ewd: '20', days_off_index: [] }
      },
      {
        name: 'expected_number_of_workers_per_shift',
        parameters: { weight: '10', enwps: '8', days_off_index: [] }
      },
      {
        name: 'consecutive_2_days_leave',
        parameters: { weight: '10', days_off_index: [] }
      },
      {
        name: 'minimum_n_days_leave_within_7_days',
        parameters: { weight: '10', mndlw7d: '2', days_off_index: [] }
      }
    ],
    days: 30,
    name_list: [
      'name1', 'name2',
      'name3', 'name4',
      'name5', 'name6',
      'name7', 'name8',
      'name9', 'name10'
    ],
    number_of_workers: 10,
    tables: [
      [
        [
          1, 1, 1, 1, 0, 0, 1, 1, 1,
          1, 1, 0, 0, 1, 1, 1, 1, 1,
          1, 1, 0, 0, 0, 0, 0, 1, 1,
          1, 1, 1
        ],
        ...
        [
          1, 1, 0, 0, 1, 1, 1, 1, 1,
          1, 0, 0, 1, 1, 1, 1, 1, 0,
          0, 1, 1, 1, 1, 1, 1, 1, 1,
          0, 0, 0
        ]
      ],
      [
      	[
          1, 1, 1, 1, 0, 0, 1, 1, 1,
          1, 1, 0, 0, 1, 1, 1, 1, 1,
          1, 1, 0, 0, 0, 0, 0, 1, 1,
          1, 1, 1
        ],
        ...
        [
          1, 1, 0, 0, 1, 1, 1, 1, 1,
          1, 0, 0, 1, 1, 1, 1, 1, 0,
          0, 1, 1, 1, 1, 1, 1, 1, 1,
          0, 0, 1
        ]

      ]
    ],
    type: 'DAU'
  }
]
\end{verbatim}
\begin{compactenum}[1.]
\item \_id: A unique object id that is automatically generated by the database.
\item shift\_id: The id of the shift. The user entity will also store \textbf{shift\_id} in the \textbf{shifts} field.
\item computation\_time: The computation time of the shift.
\item constraints: The shift requirements. The field is a nested document that stores the name of the requirement and parameters.
\item days: The number of days
\item name\_list : The name list.
\item number\_of\_workers: The number of workers in the shift.
\item tables: Tables are a 3-D array that can store multiple shifts. Each shift is a 2-D array.
\item type: The type of optimizer that solves the shift scheduling optimization problem. The type field will either be 'SA' or 'DAU'. SA means the optimization algorithm is a simulated annealing algorithm, and DAU means the problem is solved by using the digital annealing unit.
\end{compactenum}

\subsection{Sample Code}

Since we use the NoSQL database, we are only able to provide the sample code that we used to insert, search, and update the document.
The following code snippets are parts of the class DataAdapter.

\subsubsection{Search user}
\begin{verbatim}
redis_client = redis.StrictRedis(
                    host='redis-12297.c302.asia-northeast1-1.gce.cloud.redislabs.com',
                    port=12297,
                    password=''
                )
key = "eugenepassword"
json_data = redis_client.execute_command('JSON.GET', key)
user_data = json.loads(json_data)
print(json.dumps(user_data, indent=4))
\end{verbatim}

The result is
\begin{verbatim}
{
    "username": "eugene",
    "password": "password",
    "email": "email@gmail.com",
    "shifts": [
        "6885d765-1b7c-680f-f583-9011e385a991",
        "e31f03eb-a7e6-580a-e602-21e8fb22ce20",
        "533cdbce-1386-5971-ec73-fff22325ca81"
    ]
}
\end{verbatim}

\subsubsection{Update user's shifts}
The following code snippet updates the user's shifts by using the update\_one function.
\begin{verbatim}
user_collection = self.db.Users
user_collection.update_one(
	{"username": user.getUsername()}, 
	{"$set": {"shifts": user.getShifts()}}
)
\end{verbatim}

\subsubsection{Save a shift}
The following code snippet uses update\_one to save shifts, but we set upsert=True for the case that the shift doesn't originally exist. In that case, it will insert a document.
\begin{verbatim}
collection = self.db.Shifts
inserted_data = shift.getShiftConfiguration() 
inserted_data['table'] = tables
collection.update_one(
	{"shift_id" : shift.getShiftId()}, 
	{"$set": inserted_data}, 
	upsert=True
)
\end{verbatim}

\subsubsection{Load a shift}
The following code snippet will find a shift based on given shift\_id.
\begin{verbatim}
shift = self.db.Shifts.find_one({"shift_id": shift_id})
\end{verbatim}

\section{Architectural design}
The scope of the application includes the user interface, server, database, and solvers. The user interface collects the user's preference for the shift. The server components process the user's requests to load/save the data and handle the computation. The database stores and loads the users' information and shifts. Solvers are used to solve the optimization problem to generate the shift that satisfies the requirements as much as possible. After acquiring the solution from Fujitsu's server or the local solver at the server, Solvers will return the shift back to view/controller to show on the user interface. In this version, solvers use a web socket to do the communication. This allows the server to communicate the client. After the View/controller receives the shift data, it will send the data back to the server to store the data in the database. 

In this version, the server-side architecture is designed as a microservices architecture. An API gateway is responsible for managing fundamental requests, including tasks such as login, loading/saving shifts, and querying available services for clients. Additionally, the API gateway oversees the registration of microservices. When a microservice is activated, it sends a registration request to the microservices gateway. Subsequently, when a client sends a request to inquire about the currently available services, the gateway initiates a health check by sending requests to each microservice to ensure their operational status.

The following section will give details on the architecture design for each component.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{arch1}
\caption{System Architecture}
\label{sysarch}
\end{figure}

\subsection{Server}
We developed a tiny framework that enables us to flexibly extend the function of the server.  In this project, the API gateway, and two microservices are developed under this framework. Each part is able to establish a HTTP server by initializing \textbf{HttpServer} and a websocket server by initializing \textbf{WebsocketServer}. Each server can register several routes for clients to operate. 

Clients' requests are handled by each route. The route will response the data directly through the established socket connection based on the protocol.
For example, a micro-service that handles the simulated annealing solver is shown in Fig.~\ref{framework}

Here is a snippet of code that shows how to use this tiny framework.
\begin{verbatim}
class TestRoute(Route):

    def handle(self):
        data = {
            "message": "successful"
        }
        self.response.send(200, json.dumps(data), content_type="application/json")


class EchoWebsocketRoute(WebSocketRoute):

    def handle(self):
        while True:
            received_message = self._recv()
            print("Received Text: ", received_message)
            if received_message is None:
                break
            else:
                self.response.send(received_message)
                
if __name__ == '__main__':
    server = ProtocolTypeRouter({
        'http': HttpServer(routes=[(r'/', TestRoute)]),
        'websocket': WebSocketServer(routes=[(r'/chat', EchoWebsocketRoute)])
    })
    server.run()
\end{verbatim}
We just need to inherit the Route type override the handle function, and register the Route type to the corresponding server, and specify the URI.
This enables us to extend the function of the server easily. Fig.~\ref{serveruml} details the UML of the server side.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{framework}
\caption{The architecture that uses this tiny framework to create a micro-service.}
\label{framework}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{serverUML}
\caption{The UML diagram of the server}
\label{serveruml}
\end{figure}


\subsubsection{RemoteSolver}
RemoteSolver is a class that establishes the web socket connection between UI and the server. 
It also processes the message sent from the server side and connects itself and the progress bar to update the status.

We wrote two remote solvers, RemoteDAUSolver and RemoteSASolver. The corresponding APIs are ws://localhost:8888/dau and ws://localhost:8888/sa. Both solvers inherit from RemoteSolver.
When the function solve is called, it will use a web socket to send the optimization problem to the server. Here is a simple example of the data.
The data format in the communication is in the JSON format.
\begin{verbatim}
{
    "type": "SA",
    "days": 30,
    "number_of_workers": 10,
    "computation_time": 10000,
    "reserved_leave": [],
    "constraints": [
        {
            "name": "expected_number_of_working_days",
            "parameters": {
                "weight": "10",
                "ewd": "20"
            }
        },
        {
            "name": "expected_number_of_workers_per_shift",
            "parameters": {
                "weight": "8",
                "enwps": "8"
            }
        }
    ],
    "content": [
        {
            "name": "name1",
            "shift_array": ["0","0","1","1","0","0","1","1","1","1","1","0","0",
            "0","1","1","0","1","1","1","1","1","0","1","1","1","1","1","1","1"
            ]
        },
        {
            "name": "name2",
            "shift_array": [...]
        },
        ...
     ]
}

\end{verbatim}
On the server side, we defined a class SolverWebsocketRoute which inherits from WebSocketRoute. 
The class will process the request and invoke the corresponding computation service to solve the optimization problem.
We also defined two classes that inherit from SolverWebsockeRoute, which are DAUWebsocketRoute and SAWebsocketRoute.
Both give the computation service to the base class. Both DAUWebsocketRoute and SAWebsocketRoute are used in two different micro-services.
During the computation, the server will keep UI posted on the state of the computation. For example, when the problem is compiled. It will use a web socket to send
\begin{verbatim}
{"message": "status", "status" : "compiling"}.
\end{verbatim}
The user interface can update the state of the computation to the user.

\subsubsection{Data Server}
The data server uses HTTP protocol to communicate with the user interface. 
There are 5 APIs written in the server. 
Each API is handled by a Route class which inherits from the class Route and overrides the function handle.

\begin{description}
\item[Get the user]
\
\begin{description}
\item[API Endpoints:] /user
\item[Description:] Through /user URI, the server accepts the post method. The client posts a username and password to the server. 
The server will use the function getUser defined in the DataAdapter to get the user owned by the collection User. Then, the server will return the user in JSON.
\item[Method:] POST
\item[Example Request Data:]
\begin{verbatim}
{
    "username":"admin",
    "password":"password"
}
\end{verbatim}
\item[Example Response Data:]
\begin{verbatim}
{
    "username": "admin",
    "password": "password",
    "email": "admin@gmail.com",
    "shifts": [
        "10a67b34-dede-4a99-97ef-8f0b76927947"
    ]
}
\end{verbatim}
\end{description}





\item[Update user shifts]
\
\begin{description}
\item[API Endpoints:] /updateusershifts
\item[Description:] Through /updateusershifts URI, the client uses the post method to send the user’s information to the server.
The server will use the function updateUserShifts defined in the DataAdapter to update the shift\_id array which is owned by the user and stored in the collection User.
\item[Method:] POST
\item[Example Request Data:]
\begin{verbatim}
{
        "username": "admin",
        "password": "pasword",
        "email": "admin@gmail.com",
        "shifts": [
            "10a67b34-dede-4a99-97ef-8f0b76927947",
            "0fc9f879-b236-40c4-a6f6-b5f3d5c7ddab"
        ]
}

\end{verbatim}
\item[Example Response Data:]
\begin{verbatim}
no response data
\end{verbatim}
\end{description}






\item[Save a shift]
\
\begin{description}
\item[API Endpoints:] /saveshift
\item[Description:]Through /saveshift URI, the client uses the post method to send the user’s information and the shift’s information to the server. 
The server will use the function saveShift defined in the DataAdapter to save the parameters owned by the shift and stored in the collection Shifts.

\item[Method:] POST
\item[Example Request Data:]
\begin{verbatim}
{
    "shift_id": "10a67b34-dede-4a99-97ef-8f0b76927947",
    "computation_time": 10000,
    "constraints": [],
    "days": 30,
    "name_list": [ "name1", "name2", "name3", "name4", "name5",
        "name6", "name7", "name8", "name9",  "name10” ],
    "number_of_workers": 10,
    "reserved_leave": [],
    "tables": [
[ [ 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1,
 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 4 1, 1, 1 ], ...
[ 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 
1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 ] ] ],
    "type": "DAU",
}
\end{verbatim}
\item[Example Response Data:]
\begin{verbatim}
no response data
\end{verbatim}
\end{description}



\item[Load a shift]
\
\begin{description}
\item[API Endpoints:] /loadshift
\item[Description:]
\item[Method:] POST
\item[Example Request Data:]
\begin{verbatim}
{
    "shift_id":"10a67b34-dede-4a99-97ef-8f0b76927947"
}
\end{verbatim}
\item[Example Response Data:]
\begin{verbatim}
{
    "shift_id": "10a67b34-dede-4a99-97ef-8f0b76927947",
    "computation_time": 10000,
    "constraints": [],
    "days": 30,
    "name_list": [ "name1", "name2", "name3", "name4", "name5",
        "name6", "name7", "name8", "name9",  "name10” ],
    "number_of_workers": 10,
    "reserved_leave": [],
    "tables": [
[ [ 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1,
 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 4 1, 1, 1 ], ...
[ 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 
1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 ] ] ],
    "type": "DAU",
}
\end{verbatim}
\end{description}


\item[Load shifts]
\
\begin{description}
\item[API Endpoints:] /loadshifts
\item[Description:]Through /loadshifts URI, the server accepts the post method. The client posts the user’s information to the server to load all shifts for the user.
The server will use the function loadShifts defined in the DataAdapter to get all shifts owned by the user. The function loadShifts will return a list of Shift instances. Finally, the server will convert each shift in the list to a dictionary variable and store the data in a list. Then, return the data to the client.
\item[Method:] POST
\item[Example Request Data:]
\begin{verbatim}
{
        "username": "admin",
        "password": "pasword",
        "email": "admin@gmail.com",
        "shifts": [
            "10a67b34-dede-4a99-97ef-8f0b76927947",
            "0fc9f879-b236-40c4-a6f6-b5f3d5c7ddab"
        ]
}
\end{verbatim}
\item[Example Response Data:]
\begin{verbatim}
{
  "shift_list":[
{
    "shift_id": "10a67b34-dede-4a99-97ef-8f0b76927947",
    "computation_time": 10000,
    "constraints": [],
    "days": 30,
    "name_list": [ "name1", "name2", "name3", "name4", "name5",
        "name6", "name7", "name8", "name9",  "name10” ],
    "number_of_workers": 10,
    "reserved_leave": [],
    "tables": [
[ [ 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1,
 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 4 1, 1, 1 ], ...
[ 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 
1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 ] ] ],
    "type": "DAU",
},
{
    "shift_id": "0fc9f879-b236-40c4-a6f6-b5f3d5c7ddab ",
    "computation_time": 10000,
    "constraints": [{
                    "name": "expected_number_of_workers_per_shift",
                    "parameters": {
                        "weight": "20",
                        "enwps": "10",
                        "days_off_index": []
                    },
               	{
                    "name": "no_consecutive_leave",
                    "parameters": {
                        "weight": "10",
                        "days_off_index": []
                    }
                }
                }
],
    "days": 30,
    "name_list": [ "name1", "name2", "name3", "name4", "name5",
        "name6", "name7", "name8", "name9",  "name10” ],
    "number_of_workers": 10,
    "reserved_leave": [],
    "tables": [
[ [ 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1,
 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 4 1, 1, 1 ], ...
[ 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 
1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0 ] ] ],
    "type": "SA",
}
  ]
}
\end{verbatim}
\end{description}

\item[Download a shift]
\
\begin{description}
\item[API Endpoints:] /download/[shift\_id]
\item[Description:]Through /download/ URI, the server accepts the get method. The client request the server with the shift’s information to the server to download the shift.
The server will use the function loadShift defined in the DataAdapter to get the shift owned by the user. The function loadShift will return a Shift instance. Finally, the server will convert the shift to a csv file and return the data to the client.
\item[Method:] GET
\item[Example Request Data:] No need to provide the data
\item[Example Response Data:] A CSV file
\end{description}


\end{description}

\subsection{Microservices}
\begin{description}
    \item[Request for available services]
    \
    \begin{description}
        \item[API Endpoints: ] /gethealthcheck
        \item[Description: ] This API is opened to clients to check the availability of the service. The API will return the current available services and service's url. This enables clients to access micro services through those urls.
        \item[Method: ] GET
        \item[Example Request Data: ] No need to provide the data
        \item[Example Response Data: ]
        \begin{verbatim}
        [
            {
                "service": "SA",
                "status": "ON",
                "url": "ws://localhost:8890/sa",
                "healthcheck": "http://localhost:8890/healthcheck"
            },
            {
                "service": "DAU",
                "status": "ON",
                "url": "ws://localhost:8889/dau",
                "healthcheck": "http://localhost:8889/healthcheck"
            }
        ]
        \end{verbatim}
    \end{description}

    \item[Micro-service's health check]
    \
    \begin{description}
        \item[API Endpoints: ] /healthcheck
        \item[Description: ] The API will return the current status of the service. This API is available to each micro-service. Once the client request a health check, the main API gateway will send the request to each micro-service to check if the service is healthy or not.
        \item[Method: ] GET
        \item[Example Request Data: ] No need to provide the data
        \item[Example Response Data: ]
        \begin{verbatim}
        {
            "status": "healthy"
        }
        \end{verbatim}
    \end{description}


    \item[Microservices registration]
    \
    \begin{description}
        \item[API Endpoints: ] /registry/add
        \item[Description: ] The API is opened to the microservices. Once the microservice is opened, it needs to use this API to register in the server.
        \item[Method: ] POST
        \item[Example Request Data: ]
        \begin{verbatim}
        {
            "healthcheck": "http://localhost:8889/healthcheck",
            "service": "DAU", 
            'url' : "ws://localhost:8889/dau"
        }
        \end{verbatim}
        \item[Example Response Data: ]
        \begin{verbatim}
        {
            "status": "success"
        }
        \end{verbatim}
    \end{description}

    \item[Microservices delete]
    \
    \begin{description}
        \item[API Endpoints: ] /registry/delete
        \item[Description: ] The API is opened to the microservices. Once the microservice is closed, it needs to use this API to drop the microservice in the server.
        \item[Method: ] POST
        \item[Example Request Data: ]
        \begin{verbatim}
        {
            "service": "DAU", 
        }
        \end{verbatim}
        \item[Example Response Data: ]
        \begin{verbatim}
        {
            "status": "success"
        }
        \end{verbatim}
    \end{description}




\end{description}

\subsection{Database}
We design two models, User and Shift, and class DataAccess to manipulate the data in the Application.
Class User corresponds to a document in the collection Users and class Shift corresponds to a document in the collection Shifts.
Please refer to Fig.~\ref{dataadapteruml}. for the UML of the data adapter class.
Class DataAccess is an interface that will be implemented by both DataAdapter and RemoteDataAdapter.

\subsubsection{DataAdapter}
The DataAdapter will establish a connection to the MongoDB database. We can load and save the document into the collections. The following describes the function defined in the class DataAdapter.

\begin{description}
\item[getUser:]We can get the user’s information by providing the username and password to the function. The function will use username and password as a key to search and load the user's data from Redis database. If the function successfully obtain the data, it will generate an instance of class User and return the object; otherwise, return None.
\item[updateUserShifts:]We can update the user’s information by providing the document in the collection Users to the function. The function will search and update the document in the collection of Users with the given data.
\item[saveShift:]We can update the shift’s information by providing the document in the collections Users and Shifts to the function. The function will search and update the document in the collection Shifts with the given data.
\item[loadShift:]We can get the shift’s information by providing the shift\_id to the function. The function will search the document in the collection Shifts with the given data. If the function successfully gets a document from the collection, it will generate an instance of class Shift and return the object.
\item[loadShifts:]We can get the several shifts’ information by providing the document in the collection Users to the function. The function will search the document in the collection Shifts with the given data. The function will get several documents from the collection and generate a list to store the documents and return the object.
\end{description}


%\subsection{RemoteDataAdapter}
%The RemoteDataAdapter serves as a connection between the user interface and the server. When the user loads and saves data through the 
%\begin{description}
%\item[getUser:]The function will use the HTTP POST method to post the username and password, which are the parameters of the function, to the server. When the function receives the response from the server, the server will generate an instance of the class User and return.
%\item[updateUserShifts:]The function will use the HTTP POST method to post the document in the collection Users, which is the parameter of the function, to the server. When the function receives the response from the server, the server will update the document in the collection of Users with the given data.
%\item[saveShift:]The function will use the HTTP POST method to post the document in the collections Users and Shifts, which are the parameters of the function, to the server. When the function receives the response from the server, the server will update the document in the collection Shifts with the given data.
%\item[loadShift:]The function will use the HTTP POST method to post the shift\_id, which is the parameter of the function, to the server. When the function receives the response from the server, the server will generate an instance of class Shift and return.
%\item[loadShifts:]The function will use the HTTP POST method to post the document in the collection Users, which is the parameter of the function, to the server. When the function receives the response from the server, the server will generate a list to store the documents and return the object.
%\end{description}


%\subsection{UI}
%As shown in Fig.~\ref{uimainwindow}. The main window is composed of several UI components.
%The relationship between each component is presented in the Fig.~\ref{uiuml}.
%\begin{figure}
%\centering
%\includegraphics[width=\textwidth]{ui_uml}
%\caption{UI's UML}
%\label{uiuml}
%\end{figure}
\subsection{Solvers(Algorithms)}
The shift scheduling problem is modeled by the quadratic unconstrained binary optimization (QUBO) problem. 0 represents a day off and 1 represents a working day. Once the user adds shift requirements, they implicitly formulate their QUBO problem. The QUBO problem is compiled in the user's computer and solved by either the digital annealer or the simulated annealing algorithm on user's device. After the device finishes computation, the solution is then post-processed to generate the final schedule. Digital annealer is a computation service provided by Fujitsu Ltd. Digital annealer is a quantum-inspired device that is good at solving optimization problems.

In this prototype, the application offers limited shift requirements for users to choose from. The available shift requirements are listed and explained in detail below. The source code of the mathematic constraints is written in this file constraints.py.

Each constraint in the project represents a class. The constraint inherits a base class which is defined as follows:
\begin{verbatim}
class ConstraintFunction(object):
    
    def __init__(self, X:Array, **kwargs):
        self._X = X
        self._weight = float(kwargs['weight'])
        
    def hamiltonian(self) -> Model:
        pass

    def weighted_hamiltonian(self) -> Model:
        return self._weight * self.hamiltonian()
    
    def evaluate(self, table) -> dict:
        pass
\end{verbatim}

In the project, there are two solvers available. One is a digital annealer, and the other is a simulated annealing solver. The UML diagram is shown in Fig.~\ref{umlsolvers}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.08]{solvers}
\caption{UML of solvers}
\label{umlsolvers}
\end{figure}


\subsubsection{The Expected Number of Working Days}
This requirement could be added to define the number of working days in the shift range. Workers in the shift are expected to have equal working days. The mathematical formulation for $N$ workers and $D$ days shift is as follow:

$$H = \sum_{i}^{N} \left( \sum_{j}^{D}x_{ij} - \alpha \right)^2,
$$
where $\alpha$ is the expected number of working days, and $H$ is the hamiltonian.

\subsubsection{The Expected Number of Workers per Shift}

The following constraint defines the expected number of workers in each shift. This constraint is common and used to balance the workforce and the workload each day. The constraint is modeled by summing up the variables on each shift and minus the expected number of workers and, finally, double themselves and make them quadratic. The mathematical formulation is as follows:(The situation is the same as the one used above)

$$H = \sum_{j}^{D}\left( \sum_{i}^{N} - \beta\right)^2,
$$

where $\beta$ is the expected number of workers each shift.

\subsubsection{Successive Shift Pair}

This constraint is placed to make each worker has at least two consecutive shift. Here's the situation we don't want. The concept is shown below in regular expression form $((0|1)^*0 | 0^*)1(0^* | 0(0|1)^*)$

To be simple, the mathematical formulation separates the boundary situations, $(0|1)^*01$ and $10(0|1)^*$, and the general situation, $(0|1)^*010(0|1)^*$.

\subsubsection{Consecutive 2 days Leave}

This is a soft constraint for days off preference. When this constraint is employed, the algorithm would try to arrange the days off together.

The mathematical formulation is as follows:
$$H = \sum_{i}^N\sum_{j}^{D-1}\left(1-x_{i,j} * x_{i,j+1}\right)$$.

\subsubsection{No Consecutive 2 Days Leave}

This constraint is an opposite version of the above constraint. The mathematical formulation is as follows:
$$H = \sum_{i}^N\sum_{j}^{D-1}\left[(1-x_{i,j}) * (1 - x_{i,j+1})\right]$$.

\iffalse
\subsubsection{Shift Preference}

Workers are able to set up their shift preferences. They can designate which day they want to take a day off or which day they want to work. The algorithm would try to fulfill each worker's requirement.

The mathematical formulation is as follows:
$$H = \sum_{i}^N\sum_{j}^Dx_{ij}-q_{ij}$$
\fi


\subsubsection{The Maximum Consecutive Shifts}

The constraint set up a limit on the maximum number of consecutive shifts. 

This constraint could be modeled by using the supplementary variables. However, this would result in an increase in the problem scale. This technique would probably double or triple the number of original variables. Moreover, the solver, Fujitsu's digital annealer, doesn't know the meaning of each variable after compiling the solution into the accepted data; thus, after the annealing process, it would be possible to find a better solution.

The digital annealer computation service allows users to post the inequality.

The inequalities would be an array and append the following inequality.

$$\sum_{j}^{j+\gamma + 1}x_{ij} \leq \gamma, \   \forall i\in[1, N],\  j\in [1, D-\gamma - 1]$$

where $\gamma$ is the maximum consecutive shifts

\subsubsection{Minimum N-days leave within 7 days}

The constraint is for employees' days off welfare. The employees working in graveyard shifts need to have days off in a range.


\begin{figure}
\centering
\includegraphics[scale=0.05]{dataadapter}
\caption{Data Adapter UML}
\label{dataadapteruml}
\end{figure}

\section{Runnable Prototype with GUI and Video}
https://youtu.be/q6wpCm87sV8

\section{Manual for installation and usage with information on necessary libraries, frameworks, and running guidelines}

\subsection{Dependencies}
\begin{verbatim}
altgraph==0.17.3
anyio==3.7.0
appnope==0.1.3
argon2-cffi==21.3.0
argon2-cffi-bindings==21.2.0
arrow==1.2.3
astroid==2.15.3
asttokens==2.2.1
asyncio==3.4.3
attrs==23.1.0
autopep8==2.0.2
backcall==0.2.0
beautifulsoup4==4.12.2
bleach==6.0.0
certifi==2022.12.7
cffi==1.15.1
charset-normalizer==3.1.0
comm==0.1.3
contourpy==1.0.7
cycler==0.11.0
debugpy==1.6.7
decorator==5.1.1
defusedxml==0.7.1
Deprecated==1.2.13
dill==0.3.6
dimod==0.12.5
dnspython==2.4.2
docstring-to-markdown==0.12
dwave-neal==0.6.0
dwave-samplers==1.0.0
et-xmlfile==1.1.0
exceptiongroup==1.1.1
executing==1.2.0
fastjsonschema==2.17.1
flake8==6.0.0
fonttools==4.39.4
fqdn==1.5.1
gevent==23.9.1
greenlet==3.0.0
idna==3.4
ipykernel==6.23.1
ipython==8.13.2
ipython-genutils==0.2.0
ipywidgets==8.0.6
isoduration==20.11.0
isort==5.12.0
jedi==0.18.2
Jinja2==3.1.2
jsonpointer==2.3
jsonschema==4.17.3
jupyter==1.0.0
jupyter-console==6.6.3
jupyter-events==0.6.3
jupyter_client==8.2.0
jupyter_core==5.3.0
jupyter_server==2.6.0
jupyter_server_terminals==0.4.4
jupyterlab-pygments==0.2.2
jupyterlab-widgets==3.0.7
kiwisolver==1.4.4
lazy-object-proxy==1.9.0
macholib==1.16.2
MarkupSafe==2.1.2
matplotlib==3.7.1
matplotlib-inline==0.1.6
mccabe==0.7.0
mistune==2.0.5
nbclassic==1.0.0
nbclient==0.8.0
nbconvert==7.4.0
nbformat==5.8.0
nest-asyncio==1.5.6
networkx==3.1
notebook==6.5.4
notebook_shim==0.2.3
numpy==1.24.2
openpyxl==3.1.2
overrides==7.3.1
packaging==23.1
pandas==2.0.0
pandocfilters==1.5.0
parameterized==0.9.0
parso==0.8.3
pexpect==4.8.0
pickleshare==0.7.5
Pillow==9.5.0
platformdirs==3.2.0
pluggy==1.0.0
prometheus-client==0.17.0
prompt-toolkit==3.0.38
psutil==5.9.5
ptyprocess==0.7.0
pure-eval==0.2.2
pycodestyle==2.10.0
pycparser==2.21
pydocstyle==6.3.0
pyflakes==3.0.1
Pygments==2.15.1
pyinstaller==6.2.0
pyinstaller-hooks-contrib==2023.2
pylint==2.17.2
pymongo==4.5.0
pyparsing==3.0.9
PyQt6==6.5.0
PyQt6-Qt6==6.5.0
PyQt6-sip==13.5.0
pyqubo==1.4.0
pyrsistent==0.19.3
PySide6==6.5.0
PySide6-Addons==6.5.0
PySide6-Essentials==6.5.0
python-dateutil==2.8.2
python-json-logger==2.0.7
python-lsp-jsonrpc==1.0.0
python-lsp-server==1.7.2
pytoolconfig==1.2.5
pytz==2023.3
PyYAML==6.0
pyzmq==25.0.2
qtconsole==5.4.3
QtPy==2.3.1
redis==5.0.1
requests==2.28.2
rfc3339-validator==0.1.4
rfc3986-validator==0.1.1
rope==1.7.0
Send2Trash==1.8.2
shiboken6==6.5.0
six==1.16.0
sniffio==1.3.0
snowballstemmer==2.2.0
soupsieve==2.4.1
stack-data==0.6.2
terminado==0.17.1
tinycss2==1.2.1
toml==0.10.2
tomli==2.0.1
tomlkit==0.11.7
tornado==6.3.2
traitlets==5.9.0
typing_extensions==4.5.0
tzdata==2023.3
ujson==5.7.0
uri-template==1.2.0
urllib3==1.26.15
watchdog==3.0.0
wcwidth==0.2.6
webcolors==1.13
webencodings==0.5.1
websocket==0.2.1
websocket-client==1.5.2
websockets==11.0.3
whatthepatch==1.0.4
widgetsnbextension==4.0.7
wrapt==1.15.0
yapf==0.32.0
zope.event==5.0
zope.interface==6.1
\end{verbatim}

\subsection{Server}
To launch the server, install the dependencies mentioned above. The API gateway is implemented in server.py. To initiate the server, begin by editing config.yaml to adhere to the following format:
\begin{verbatim}
dau_url: "https://api.aispf.global.fujitsu.com"
dma_url: "https://dau.emath.tw"
dau_api_key: ""
dma_api_key: ""
mongodb_uri: "mongodb://"
\end{verbatim}.

Subsequently, proceed to start the server.
\begin{verbatim}
python3 server
\end{verbatim}.

Once the server is up and running, you can initiate the microservices.
\begin{verbatim}
python3 OSC.py
python3 FS.py
\end{verbatim}

\subsection{Client}
Access http://localhost:8888/ to interact with the client, or you can double click the "webview" executable binary file. However, the file is precompiled in MacOS so that it is only able to run on MacOS system. In other system, we recommend you type the following command to lunch the desktop application

\begin{verbatim}
python3 webview.py
\end{verbatim}
\end{document}  